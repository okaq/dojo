<!DOCTYPE html>
<html lang="en">
    <head id="zeta">
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <meta name="viewport" content="width=1920,height=1080,initial-scale=1" />
        <meta name="source" content="https://github.com/okaq/akari" />
        <meta name="author" content="AQ<aq@okaq.com>" />
        <meta name="date" content="2019-04-18" />
        <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAMklEQVR4nGI5O/s/Ay0BE01NH7Vg1IJRC0YtGLVg1IJRC0YtGLVg1IJRC6gIAAEAAP//0iICqtEdyE8AAAAASUVORK5CYII=" />
        <style type="text/css">
            html,body{width:1920px;overflow:auto;height:1080px;margin:0px;border:0px;padding:0px;background-color:rgba(0,0,0,0);}
        </style>
        <!-- openType.js -->
        <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js"></script>
        <script type="text/javascript">
            // ok
            console.log("okaq akari ok!");
            // async load
            (function() {
                var a = {
                    "load": function(e) {
                        console.log(e);
                        g.init();
                    }
                }
                document.addEventListener("DOMContentLoaded", a.load, false);
            })();
// game
var g = {
        "init": function() {
            var t0 = window.performance.now();
            console.log("start akari...");

            // subs
            g.subs = [dom,sce,pod];
            g.subs.forEach(function(el){el.init();});

            // wait and begin
            // window.setTimeout(g.start, 1000);
            window.setTimeout(g.start, 1000);
        },
        "start": function() {
            // clear
            ren.bkgd();
            ren.pane();
            // net pid
            // async font load
            net.moji();

            // loop
            g.tick = 0;
            // g.id = window.setInterval(g.frame, 1000);
            // slow down for threholding
            g.id = window.setInterval(g.frame, 5000);
        },
        "frame": function() {
            // tick test
            if (g.tick >= net.noto.numGlyphs) {
                console.log("anim done");
                window.clearInterval(g.id);
                return;
            }
            console.log("glyph # " + g.tick + " / " + net.noto.numGlyphs);
            console.log("glyph name = " + net.noto.glyphs.glyphs[g.tick].name);
            console.log("glyph code point: " + net.noto.glyphs.glyphs[g.tick].unicode);
            var s0 = String.fromCharCode(net.noto.glyphs.glyphs[g.tick].unicode);
            sce.b.t2 = s0;
            var s2 = net.noto.glyphs.glyphs[g.tick].unicode;
            // metrics
            var b0 = net.noto.glyphs.glyphs[g.tick].getBoundingBox();
            console.log(b0);
            // use measure text object to get scaled size
            // console.log(typeof(s2));
            // var s3 = String.fromCodePoint(s2);
            // console.log("\\u" + s2);
            // var s1 = String.fromCodePoint(parseInt(net.noto.glyphs.glyphs[g.tick].unicode));
            // sce.b.t3 = s1;
            var s3 = "";
            // 16-bit max 65535
            if (s2 >= 12600) {
                s3 = String.fromCodePoint(s2);
                sce.b.t2 = s3;
            }
            console.log(s3);
            console.log(s0);
            // increment code point index
            // render and sample glyph
            // begins glitch after 12953
            // code point 1042476
            // ren.glyph();
            // ren.glyph2();
            ren.glyph3();
            // sample pixel data
            // sce.buff();
            sce.buff3();
            // threshold
            // sce.thresh();
            sce.thresh3();

            g.tick = g.tick + 1;
        }
    }
// scene
var sce = {
    "init": function() {
        // bkgd
        sce.a = {};
        sce.a.r = [1920,1080,0,0];
        sce.a.c = dom.canvas(sce.a.r);
        dom.add(sce.a.c);
        // pane
        sce.b = {};
        sce.b.r = [512,512,734,284];
        sce.b.c = dom.canvas(sce.b.r);
        // dom.add(sce.b.c);
        // pane 2 - increase to 1024 x 1024
        sce.d = {};
        sce.d.r = [1024,1024,448,28];
        sce.d.c = dom.canvas(sce.d.r);
        dom.add(sce.d.c);
    },
    "moji": function() {
        // unicode code points
        // '\u263A' = 'smileface'
        sce.b.t = '\u263A';
        ren.txt();
    },
    "buff": function() {
        // back buffer
        sce.c = {};
        sce.c.p = sce.b.c.con.getImageData(0,0,sce.b.c.can.width,sce.b.c.can.height);
        sce.c.t = sce.c.p.data;
        console.log(sce.c.t.length);
    },
    "buff2": function() {
        // idea is to have three
        // "synchronous" buffers per image
        sce.e = [];
    },
    "buff3": function() {
        // per tick, init image buffers
        sce.e[g.tick] = {};
        // rgba pixel data 1024x1024x4
        sce.e[g.tick].a = sce.d.c.con.getImageData(0,0,sce.d.c.can.width,sce.d.c.can.height);
        // monochrome black white bit array 1024x1024
        sce.e[g.tick].b = [];
        // thresholded pixel block bit array 32x32
        sce.e[g.tick].c = [];
    },
    "thresh": function() {
        // loop over 1024 32x32 pixel blocks
        for (var i = 0; i < 1024; i++) {
            // obtain pixel data index
            var i0 = pod.dex(i);
            // debug infor for center block
            if (i == 512) {
                console.log("center point index 512");
            }
        }
    },
    "thresh2": function() {
        // init image buffers
        sce.buff3();
        // sce.e[g.tick] = {};
        // pixel blocks
        for (var i = 0; i < 1024; i++) {
            // decomp
            var x0 = i % pod.nx;
            var y0 = (i / pod.nx) >>> 0;
            var i0 = (x0 * pod.nx) >>> 0;
            var i1 = (y0 * pod.ry) >>> 0;
            var i2 = (i0 + i1) >>> 0;
            // obtain pixels indicies at block
        }

        // per image, three buffers
        // pixel block data, 32x32
        // image pixels, 1024x1024
        // raw rgba, 1024x1024x4
    },
    "thresh3": function() {
        // init image buffers
        sce.buff3();
        // populate monochrome bit array
        sce.mono();
        // loop over 1024 32x32 pixel blocks
        for (var i = 0; i < 1024; i++) {
        }
    },
    "mono": function() {
        // loop over pixels
        for (var y = 0; y < pod.h; y++) {
            for (var x = 0; x < pod.x; x++) {
                // get index
                var i0 = pod.dex2(x0, y0);
                // rgba index
                var i1 = (i0 * 4) >>> 0;
                // rgba value
                var c0 = sce.rgba2(i1);
            }
        }
    },
    "rgba": function(i0) {
        // pixel data
        var r0 = [];
        var i2 = (i0 * 4) >>> 0;
        r0[0] = i2+0;
        r0[1] = i2+1;
        r0[2] = i2+2;
        r0[3] = i2+3;
        return r0;
    },
    "rgba2": function(i0) {
        var c0 = [];

        c0[0] = sce.e[g.tick].a.data[i0+0];
        c0[1] = sce.e[g.tick].a.data[i0+1];
        c0[2] = sce.e[g.tick].a.data[i0+2];
        c0[3] = sce.e[g.tick].a.data[i0+3];
        
        return c0;
    },
    "dete": function(c0, c1) {
        // rgba compare
        for (var i = 0; i < c0.length; i++) {
            if (c0[i] != c1[i]) {
                return false;
            }
        }
        return true;
    }
}
// pixel data
var pod = {
    "init": function() {
        pod.w = 1024;
        pod.h = 1024;
        pod.nx = 32;
        pod.ny = 32;
        // image stride
        pod.rx = pod.w;
        pod.ry = (pod.w * pod.nx) >>> 0;
        // stride of rgba data
        pod.sx = (pod.nx * 4);
        pod.sy = (pod.sx * pod.nx) >>> 0;
        pod.nt = (pod.nx * pod.ny) >>> 0;
        console.log(pod);
    },
    "dex": function(i0) {
        // index into rgba pixel data
        var x0 = i0 % pod.nx;
        var y0 = (i0 / pod.nx) >>> 0;
        var i1 = (y0 * pod.sy) >>> 0;
        var x1 = (x0 * 4) >>> 0;
        var i2 = (i1 + x1) >>> 0;
        return i2;
    },
    "dex2": function(x0, y0) {
        var i0 = (y0 * pod.w) >>> 0;
        var i1 = (i0 + x0) >>> 0;
        return i1;
    },
    "bloc": function(i0) {
        // set of indicies in pixel block
        var r0 = [];
        for (var y = 0; y < pod.ny; y++) {
            for (var x = 0; x < pod.nx; x++) {
                var i1 = (i0 + x) >>> 0;
                var i2 = (pod.nx * pod.w) * y;
            }
        }
        return r0;
    }
}
// xhr
var net = {
    "moji": function() {
        window.fetch("/e")
            .then(resp => resp.arrayBuffer())
            .then(font => {
                const fontFace = new FontFace("Noto Emoji", font);
                document.fonts.add(fontFace);
                // document.body.style.fontFamily = '"Noto Emoji", Arial';
                document.body.style.fontFamily = "Noto Emoji";

                // opentype query
                net.noto = opentype.parse(font);
                console.log(net.noto);

                sce.moji();
            })
    },
    "flip": function() {
        // fetch with Array Buffer payload
        // 1024 bit array sample
        // 
    }
}
// render
var ren = {
    "bkgd": function() {
        sce.a.c.con.fillStyle = rgba.css([0,0,0,1.0]);
        sce.a.c.con.fillRect(0,0,sce.a.c.can.width,sce.a.c.can.height);
    },
    "pane": function() {
        sce.b.c.con.fillStyle = rgba.css([255,255,255,1.0]);
        sce.b.c.con.fillRect(0,0,sce.b.c.can.width,sce.b.c.can.height);
    },
    "txt": function() {
        sce.b.c.con.fillStyle = rgba.css([0,0,0,1.0]);
        sce.b.c.con.font = '128px "Noto Emoji"';
        sce.b.c.con.fillText(sce.b.t, 32, 256);
    },
    "glyph": function() {
        // rng bkgd
        sce.a.c.con.fillStyle = rgba.rand();
        sce.a.c.con.fillRect(0,0,sce.a.c.can.width,sce.a.c.can.height);
        // rng pane
        sce.b.c.con.fillStyle = rgba.rand();
        sce.b.c.con.fillRect(0,0,sce.b.c.can.width,sce.b.c.can.height);
        // rng font
        sce.b.c.con.fillStyle = rgba.rand();
        sce.b.c.con.font = '400px "Noto Emoji"';
        // measurement to detrmine dynamic centering
        // var m0 = sce.b.c.con.measureText(sce.b.t2);
        // console.log(m0);
        // width = 507.8125, monospace
        sce.b.c.con.fillText(sce.b.t2, 2, 400);
    },
    "glyph2": function() {
        // black bkgd
        sce.a.c.con.fillStyle = rgba.css([0,0,0,1.0]);
        sce.a.c.con.fillRect(0,0,sce.a.c.can.width,sce.a.c.can.height);
        // white pane
        sce.b.c.con.fillStyle = rgba.css([255,255,255,1.0]);
        sce.b.c.con.fillRect(0,0,sce.b.c.can.width,sce.b.c.can.height);
        // black font
        sce.b.c.con.fillStyle = rgba.css([0,0,0,1.0]);
        sce.b.c.con.font = '400px "Noto Emoji"';
        // measurement to detrmine dynamic centering
        // var m0 = sce.b.c.con.measureText(sce.b.t2);
        // console.log(m0);
        // width = 507.8125, monospace
        sce.b.c.con.fillText(sce.b.t2, 2, 400);
    },
    "glyph3": function() {
        // black bkgd
        sce.a.c.con.fillStyle = rgba.css([0,0,0,1.0]);
        sce.a.c.con.fillRect(0,0,sce.a.c.can.width,sce.a.c.can.height);
        // white pane
        sce.d.c.con.fillStyle = rgba.css([255,255,255,1.0]);
        sce.d.c.con.fillRect(0,0,sce.d.c.can.width,sce.d.c.can.height);
        // black font
        sce.d.c.con.fillStyle = rgba.css([0,0,0,1.0]);
        sce.d.c.con.font = '800px "Noto Emoji"';
        // measurement to detrmine dynamic centering
        // var m0 = sce.d.c.con.measureText(sce.b.t2);
        // console.log(m0);
        // width = 1015.625, monospace
        sce.d.c.con.fillText(sce.b.t2, 2, 800);
    }
}
   // dom
   var dom = {
        "init": function() {
            dom.alpha = document.getElementById("alpha");
            console.log(dom.alpha);
        },
        "canvas": function(r0) {
            var c0 = {};
            c0.can = document.createElement("canvas");
            c0.con = c0.can.getContext("2d");
            c0.can.width = r0[0];
            c0.can.height = r0[1];
            c0.can.style.position = "absolute";
            c0.can.style.top = r0[3] + "px";
            c0.can.style.left = r0[2] + "px";
            return c0;
        },
        "canvas2": function(r0) {
            var c0 = {};
            c0.can = document.createElement("canvas");
            // c0.con = c0.can.getContext("2d");
            // let babylonjs create the wegbl context
            c0.can.width = r0[0];
            c0.can.height = r0[1];
            c0.can.style.position = "absolute";
            c0.can.style.top = r0[3] + "px";
            c0.can.style.left = r0[2] + "px";
            return c0;
        },
        "add": function(c0) {
            dom.alpha.appendChild(c0.can);
        },
        "remove": function(c0) {
            dom.alpha.removeChild(c0.can);
        }
    }
    // colors
    var rgba = {
        "rc": function() {
            // return random rgba
            var c0 = [
                rgba.rb(),
                rgba.rb(),
                rgba.rb(),
                1.0
                ];
            return c0;
        },
        "css": function(c0) {
            // return css string
            return "rgba(" + c0.join(",") + ")";
        },
        "rb": function() {
            // random byte
            return (Math.random() * 255) >>> 0;
        },
        "rba": function(size0) {
            // random byte array length of input
            var r0 = [];
            for (var i = 0; i < size0; i++) {
                r0.push(rgba.rb());
            }
            return r0;
        },
        "rand": function() {
            return rgba.css(rgba.rc());
        },
        "mono": function(c0) {
            return rgba.css([c0,c0,c0,1.0]);
        },
        "rmon": function() {
            var c0 = rgba.rb();
            return rgba.mono(c0);
        }
    }

</script>
        </head>
        <body id="alpha">
        </body>
    </html>

